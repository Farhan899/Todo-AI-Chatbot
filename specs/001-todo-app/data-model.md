# Data Model: Multi-User Todo Application

**Feature**: 001-todo-app
**Date**: 2025-12-28
**Phase**: 1 (Entity Design & Schema Definition)

## Overview

This document defines the data entities, relationships, validation rules, and database schema for the multi-user todo application. The model enforces strict user isolation at the database level with indexed user_id fields for query performance.

## Entity Relationship Diagram

```
┌─────────────────────┐
│       User          │
│                     │
│  - id (PK)          │
│  - email (unique)   │
│  - password_hash    │
│  - created_at       │
└──────────┬──────────┘
           │
           │ 1:N (one user, many tasks)
           │
           ▼
┌─────────────────────┐
│       Task          │
│                     │
│  - id (PK)          │
│  - user_id (FK, idx)│◄─── Indexed for performance
│  - title            │
│  - description      │
│  - is_completed     │
│  - created_at       │
│  - updated_at       │
└─────────────────────┘
```

**Key Relationships**:
- One User has many Tasks (1:N)
- Each Task belongs to exactly one User
- No shared tasks or task collaboration (explicit out-of-scope per spec)

---

## Entity 1: User

**Purpose**: Represents an authenticated user account. Managed primarily by Better Auth library with custom extensions for user_id indexing.

### SQLModel Schema

```python
from sqlmodel import Field, SQLModel
from datetime import datetime
from typing import Optional

class User(SQLModel, table=True):
    """
    User entity managed by Better Auth.
    Extended for application-specific needs.
    """
    __tablename__ = "users"

    # Primary Key
    id: str = Field(primary_key=True, description="UUID or ulid generated by Better Auth")

    # Authentication Fields (managed by Better Auth)
    email: str = Field(unique=True, index=True, max_length=255, description="Unique email address")
    password_hash: str = Field(description="Hashed password (bcrypt/argon2)")
    email_verified: bool = Field(default=False, description="Email verification status")

    # Metadata
    created_at: datetime = Field(default_factory=datetime.utcnow, description="Account creation timestamp")
    updated_at: datetime = Field(
        default_factory=datetime.utcnow,
        sa_column_kwargs={"onupdate": datetime.utcnow},
        description="Last update timestamp"
    )

    # Configuration
    class Config:
        json_schema_extra = {
            "example": {
                "id": "usr_01H5YZ6X8P9Q2R3S4T5V6W7X8",
                "email": "user@example.com",
                "email_verified": True,
                "created_at": "2025-12-28T10:00:00Z",
                "updated_at": "2025-12-28T10:00:00Z"
            }
        }
```

### Field Specifications

| Field | Type | Constraints | Nullable | Description |
|-------|------|-------------|----------|-------------|
| `id` | String (UUID/ULID) | PRIMARY KEY | No | Unique user identifier (generated by Better Auth) |
| `email` | String | UNIQUE, INDEX, max_length=255 | No | User's email address (used for login) |
| `password_hash` | String | - | No | Hashed password (never stored in plaintext) |
| `email_verified` | Boolean | DEFAULT FALSE | No | Whether email has been verified |
| `created_at` | DateTime | DEFAULT CURRENT_TIMESTAMP | No | When account was created |
| `updated_at` | DateTime | DEFAULT CURRENT_TIMESTAMP ON UPDATE | No | When account was last modified |

### Validation Rules

- **Email Format**: Must match RFC 5322 email pattern (validated by Pydantic EmailStr)
- **Password Requirements**: Minimum 8 characters (enforced by Better Auth, per FR-002)
- **Uniqueness**: Email must be unique across all users (database constraint)

### Indexes

```sql
CREATE UNIQUE INDEX idx_user_email ON users(email);
CREATE INDEX idx_user_created_at ON users(created_at);  -- For analytics/reporting
```

**Rationale**: Email index enables fast login lookups. created_at index supports user growth queries.

### Security Considerations

- **Password Storage**: Never store plaintext passwords. Better Auth handles hashing with bcrypt or argon2.
- **No PII Exposure**: User model excluded from public API responses (JWT contains only `id` in `sub` claim).
- **Email Privacy**: User emails never exposed to other users (no user search/listing features).

---

## Entity 2: Task

**Purpose**: Represents a single todo item owned by a user. Core entity for CRUD operations.

### SQLModel Schema

```python
from sqlmodel import Field, SQLModel
from datetime import datetime
from typing import Optional

class Task(SQLModel, table=True):
    """
    Task entity representing a todo item.
    Strictly user-isolated via user_id foreign key.
    """
    __tablename__ = "tasks"

    # Primary Key
    id: int = Field(default=None, primary_key=True, description="Auto-incrementing task ID")

    # Foreign Key (User Isolation)
    user_id: str = Field(
        foreign_key="users.id",
        index=True,  # CRITICAL: Index for query performance
        description="Owner's user ID"
    )

    # Task Data
    title: str = Field(min_length=1, max_length=200, description="Task title (required)")
    description: Optional[str] = Field(default=None, max_length=2000, description="Task description (optional)")
    is_completed: bool = Field(default=False, description="Completion status")

    # Metadata
    created_at: datetime = Field(default_factory=datetime.utcnow, description="Task creation timestamp")
    updated_at: datetime = Field(
        default_factory=datetime.utcnow,
        sa_column_kwargs={"onupdate": datetime.utcnow},
        description="Last update timestamp"
    )

    # Configuration
    class Config:
        json_schema_extra = {
            "example": {
                "id": 42,
                "user_id": "usr_01H5YZ6X8P9Q2R3S4T5V6W7X8",
                "title": "Complete project documentation",
                "description": "Write technical specs and API docs",
                "is_completed": False,
                "created_at": "2025-12-28T10:30:00Z",
                "updated_at": "2025-12-28T10:30:00Z"
            }
        }
```

### Field Specifications

| Field | Type | Constraints | Nullable | Description |
|-------|------|-------------|----------|-------------|
| `id` | Integer | PRIMARY KEY, AUTO_INCREMENT | No | Unique task identifier |
| `user_id` | String (UUID/ULID) | FOREIGN KEY(users.id), INDEX | No | Owner's user ID (for isolation) |
| `title` | String | min_length=1, max_length=200 | No | Task title (required, non-empty) |
| `description` | String | max_length=2000 | Yes | Task description (optional) |
| `is_completed` | Boolean | DEFAULT FALSE | No | Whether task is marked complete |
| `created_at` | DateTime | DEFAULT CURRENT_TIMESTAMP | No | When task was created |
| `updated_at` | DateTime | DEFAULT CURRENT_TIMESTAMP ON UPDATE | No | When task was last modified |

### Validation Rules

**Title (FR-008)**:
- **Required**: Cannot be null or empty
- **Min Length**: 1 character after trimming whitespace
- **Max Length**: 200 characters
- **Whitespace Handling**: Leading/trailing whitespace trimmed, purely whitespace titles rejected

**Description (FR-009)**:
- **Optional**: Can be null
- **Max Length**: 2000 characters
- **Empty Strings**: Treated as null (normalized in Pydantic schema)

**Completion Status (FR-013)**:
- **Boolean**: Only `true` or `false` (no intermediate states)
- **Default**: `false` (new tasks are incomplete)

**Timestamps (FR-014)**:
- **created_at**: Set once on creation, never modified
- **updated_at**: Automatically updated on every PUT/PATCH operation

### Pydantic Validation Schemas

```python
from pydantic import BaseModel, Field, validator

class TaskCreate(BaseModel):
    """Schema for creating a new task (POST request)"""
    title: str = Field(..., min_length=1, max_length=200)
    description: Optional[str] = Field(None, max_length=2000)

    @validator('title')
    def title_not_whitespace(cls, v):
        if not v.strip():
            raise ValueError('Title cannot be empty or whitespace only')
        return v.strip()

    @validator('description')
    def normalize_description(cls, v):
        if v is not None and not v.strip():
            return None  # Convert empty strings to null
        return v

class TaskUpdate(BaseModel):
    """Schema for updating an existing task (PUT request)"""
    title: Optional[str] = Field(None, min_length=1, max_length=200)
    description: Optional[str] = Field(None, max_length=2000)

    @validator('title')
    def title_not_whitespace(cls, v):
        if v is not None and not v.strip():
            raise ValueError('Title cannot be empty or whitespace only')
        return v.strip() if v else v

    @validator('description')
    def normalize_description(cls, v):
        if v is not None and not v.strip():
            return None
        return v

class TaskResponse(BaseModel):
    """Schema for task API responses (GET, POST, PUT responses)"""
    id: int
    user_id: str
    title: str
    description: Optional[str]
    is_completed: bool
    created_at: datetime
    updated_at: datetime

    class Config:
        orm_mode = True  # Enable SQLModel conversion
```

### Indexes

```sql
CREATE INDEX idx_task_user_id ON tasks(user_id);                           -- CRITICAL: User isolation queries
CREATE INDEX idx_task_user_id_created_at ON tasks(user_id, created_at);   -- Ordered task lists
CREATE INDEX idx_task_user_id_completed ON tasks(user_id, is_completed);  -- Filter by completion status
```

**Index Rationale**:
1. **idx_task_user_id**: Primary query pattern (`WHERE user_id = ?`) for user isolation (Principle V)
2. **idx_task_user_id_created_at**: Composite index for sorting tasks by creation time within user scope
3. **idx_task_user_id_completed**: Composite index for filtering completed/incomplete tasks

**Query Performance**:
- Single-user task list: O(log n) lookup via index + sequential scan of user's tasks
- Expected per-user task count: <1000 (reasonable for todo app)
- Index overhead: Minimal (task writes are infrequent compared to reads)

### State Transitions

```
┌─────────────────┐
│   Created       │  is_completed = False
│  (Initial)      │
└────────┬────────┘
         │
         │ PATCH /tasks/{id}/complete (toggle)
         ▼
┌─────────────────┐
│   Completed     │  is_completed = True
│                 │
└────────┬────────┘
         │
         │ PATCH /tasks/{id}/complete (toggle)
         ▼
┌─────────────────┐
│  Incomplete     │  is_completed = False
│  (reopened)     │
└─────────────────┘
```

**Transitions**:
- **Create** → Incomplete (default)
- **Incomplete** ⇄ **Complete** (toggle via PATCH endpoint)
- **Delete**: Permanent removal (no soft delete, per spec FR-012)

### Business Rules

1. **User Ownership**: Every task MUST have a `user_id` (enforced by NOT NULL constraint)
2. **No Orphans**: If a user is deleted, all their tasks MUST be deleted (CASCADE foreign key)
3. **No Sharing**: Tasks cannot be transferred between users (no update user_id endpoint)
4. **No Collaborative Editing**: Tasks are single-owner only (out-of-scope per spec)

### Security Constraints

**Database Level**:
```sql
-- Foreign key with CASCADE delete (user deletion removes all tasks)
ALTER TABLE tasks
ADD CONSTRAINT fk_task_user
FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;

-- Check constraint: title cannot be empty string
ALTER TABLE tasks
ADD CONSTRAINT chk_task_title_not_empty
CHECK (LENGTH(TRIM(title)) > 0);
```

**Application Level** (enforced in API):
- Every query MUST include `WHERE user_id = current_user_id` (Principle V)
- JWT user_id MUST match URL `{user_id}` parameter (Principle II)
- Create/Update operations validate user_id matches authenticated user

---

## Entity 3: JWT Token (Logical Entity)

**Purpose**: Represents the authentication token used for stateless auth. Not persisted in database (exists only in transit and client storage).

### Token Structure

```json
{
  "sub": "usr_01H5YZ6X8P9Q2R3S4T5V6W7X8",  // User ID
  "iat": 1735392000,                       // Issued at (Unix timestamp)
  "exp": 1735478400,                       // Expires at (iat + 24 hours)
  "aud": "neon-fastapi-next-todo"          // Audience (optional)
}
```

### Field Specifications

| Claim | Type | Description |
|-------|------|-------------|
| `sub` (Subject) | String | User ID (references users.id) |
| `iat` (Issued At) | Integer | Unix timestamp when token was created |
| `exp` (Expiration) | Integer | Unix timestamp when token expires (24 hours from iat) |
| `aud` (Audience) | String | Application identifier (optional, for multi-app scenarios) |

### Validation Rules

**Backend Verification** (app/core/security.py):
```python
from jose import jwt, JWTError
from datetime import datetime

def decode_jwt(token: str, secret: str) -> dict:
    """
    Decode and validate JWT token.

    Raises:
        HTTPException(401): If token is invalid, expired, or missing required claims
    """
    try:
        payload = jwt.decode(
            token,
            secret,
            algorithms=["HS256"],  # Enforced by Principle II
            options={"verify_aud": False}  # Audience verification optional
        )

        # Verify required claims
        if "sub" not in payload:
            raise HTTPException(status_code=401, detail="Token missing user ID")

        # Expiration checked automatically by jwt.decode (raises ExpiredSignatureError)

        return payload

    except ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token has expired")
    except JWTError as e:
        raise HTTPException(status_code=401, detail=f"Invalid token: {str(e)}")
```

### Lifecycle

1. **Issuance**: Better Auth generates token on successful login (frontend)
2. **Storage**: Stored in secure cookie or session storage (frontend)
3. **Transmission**: Sent in `Authorization: Bearer <token>` header (every API request)
4. **Verification**: FastAPI dependency decodes and validates (backend)
5. **Expiration**: After 24 hours, token becomes invalid (user must re-login)
6. **Revocation**: Logout clears token from client (no server-side revocation needed for stateless auth)

### Security Properties

- **Stateless**: No server-side session storage required
- **Tamper-Proof**: HMAC signature prevents modification
- **Time-Limited**: 24-hour expiration reduces compromise window
- **User-Scoped**: `sub` claim identifies user for authorization checks

---

## Database Schema (SQL DDL)

Complete schema for PostgreSQL with all constraints, indexes, and triggers:

```sql
-- Enable UUID extension (if using UUIDs for user IDs)
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Users table (managed by Better Auth, extended for app)
CREATE TABLE users (
    id VARCHAR(255) PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    email_verified BOOLEAN DEFAULT FALSE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

-- Indexes for users
CREATE UNIQUE INDEX idx_user_email ON users(email);
CREATE INDEX idx_user_created_at ON users(created_at);

-- Tasks table
CREATE TABLE tasks (
    id SERIAL PRIMARY KEY,
    user_id VARCHAR(255) NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(200) NOT NULL,
    description VARCHAR(2000),
    is_completed BOOLEAN DEFAULT FALSE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,

    -- Constraints
    CONSTRAINT chk_task_title_not_empty CHECK (LENGTH(TRIM(title)) > 0)
);

-- Indexes for tasks
CREATE INDEX idx_task_user_id ON tasks(user_id);
CREATE INDEX idx_task_user_id_created_at ON tasks(user_id, created_at DESC);
CREATE INDEX idx_task_user_id_completed ON tasks(user_id, is_completed);

-- Trigger for automatic updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_task_updated_at
    BEFORE UPDATE ON tasks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

---

## Migration Strategy

**Tool**: Alembic (per research.md decision)

**Initial Migration** (`alembic/versions/001_initial_schema.py`):
```python
"""Initial schema: users and tasks

Revision ID: 001
Create Date: 2025-12-28
"""

from alembic import op
import sqlalchemy as sa

def upgrade():
    # Users table
    op.create_table(
        'users',
        sa.Column('id', sa.String(255), primary_key=True),
        sa.Column('email', sa.String(255), unique=True, nullable=False),
        sa.Column('password_hash', sa.String(255), nullable=False),
        sa.Column('email_verified', sa.Boolean(), server_default='false', nullable=False),
        sa.Column('created_at', sa.DateTime(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False),
        sa.Column('updated_at', sa.DateTime(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False),
    )
    op.create_index('idx_user_email', 'users', ['email'], unique=True)
    op.create_index('idx_user_created_at', 'users', ['created_at'])

    # Tasks table
    op.create_table(
        'tasks',
        sa.Column('id', sa.Integer(), primary_key=True, autoincrement=True),
        sa.Column('user_id', sa.String(255), sa.ForeignKey('users.id', ondelete='CASCADE'), nullable=False),
        sa.Column('title', sa.String(200), nullable=False),
        sa.Column('description', sa.String(2000), nullable=True),
        sa.Column('is_completed', sa.Boolean(), server_default='false', nullable=False),
        sa.Column('created_at', sa.DateTime(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False),
        sa.Column('updated_at', sa.DateTime(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False),
        sa.CheckConstraint("LENGTH(TRIM(title)) > 0", name='chk_task_title_not_empty'),
    )
    op.create_index('idx_task_user_id', 'tasks', ['user_id'])
    op.create_index('idx_task_user_id_created_at', 'tasks', ['user_id', 'created_at'])
    op.create_index('idx_task_user_id_completed', 'tasks', ['user_id', 'is_completed'])

def downgrade():
    op.drop_table('tasks')
    op.drop_table('users')
```

**Migration Commands**:
```bash
# Create migration
alembic revision --autogenerate -m "Initial schema"

# Apply migration
alembic upgrade head

# Rollback
alembic downgrade -1
```

---

## Data Integrity Rules

### Referential Integrity

1. **User → Task Relationship**: Tasks MUST reference valid user (enforced by foreign key)
2. **Cascade Delete**: When user deleted, all their tasks deleted automatically
3. **No Orphan Tasks**: Cannot exist task without user_id

### Data Quality

1. **Title Validation**: Non-empty after trimming (check constraint + Pydantic)
2. **Length Limits**: Title ≤200 chars, Description ≤2000 chars (enforced at DB + API layer)
3. **Timestamp Accuracy**: Timestamps use database server time (avoid client clock skew)

### Consistency

1. **Atomic Updates**: Use database transactions for multi-row updates
2. **Optimistic Locking**: Consider adding `version` column if concurrent edits become issue (currently out-of-scope)
3. **Query Isolation**: All queries filter by user_id (no cross-user data leakage)

---

## Testing Data

**Seed Data for Development** (backend/tests/fixtures/seed_data.py):
```python
# Test user
test_user = {
    "id": "test_user_001",
    "email": "test@example.com",
    "password_hash": "$2b$12$...",  # Hashed "password123"
    "email_verified": True,
}

# Test tasks
test_tasks = [
    {
        "id": 1,
        "user_id": "test_user_001",
        "title": "Complete project setup",
        "description": "Initialize repo, configure environment",
        "is_completed": True,
    },
    {
        "id": 2,
        "user_id": "test_user_001",
        "title": "Write API documentation",
        "description": None,
        "is_completed": False,
    },
]
```

---

## Performance Considerations

### Query Patterns

**Most Common**:
1. List user's tasks: `SELECT * FROM tasks WHERE user_id = ? ORDER BY created_at DESC`
2. Get single task: `SELECT * FROM tasks WHERE id = ? AND user_id = ?`
3. Update task: `UPDATE tasks SET title = ?, updated_at = NOW() WHERE id = ? AND user_id = ?`

**Index Coverage**:
- Pattern 1: Covered by `idx_task_user_id_created_at`
- Pattern 2: Covered by primary key + `idx_task_user_id`
- Pattern 3: Covered by primary key + `idx_task_user_id`

### Expected Load

- **Users**: 100 concurrent (per spec SC-007)
- **Tasks per user**: <1000 (reasonable assumption)
- **Total tasks**: ~100,000 (100 users × 1000 tasks avg)
- **Query frequency**: ~5 queries/user/minute (list, create, update, toggle, delete)

**Database Size Estimation**:
- Task row: ~300 bytes (with indexes)
- 100k tasks: ~30 MB
- Growth: +10 MB/month (assuming 1000 new tasks/month)

---

## Summary

**Entities**:
- ✅ User: Managed by Better Auth, extended for app needs
- ✅ Task: Core entity with strict user isolation
- ✅ JWT Token: Logical entity for stateless auth

**Key Design Decisions**:
- ✅ Indexed `user_id` for query performance (Principle V)
- ✅ Automatic timestamps (created_at, updated_at)
- ✅ Validation at DB + API layers (defense in depth)
- ✅ CASCADE delete (user removal cleans up tasks)
- ✅ No soft delete (permanent removal per FR-012)

**Next Phase**: Generate API contracts (OpenAPI spec) in contracts/api.openapi.yaml
